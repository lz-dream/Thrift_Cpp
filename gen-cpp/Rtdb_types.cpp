/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "Rtdb_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace cn { namespace oge { namespace kdm { namespace rtdb { namespace thrift { namespace api {

int _kRtSummaryTypeValues[] = {
  RtSummaryType::MAX_VAL,
  RtSummaryType::MIN_VAL,
  RtSummaryType::AVG_VAL
};
const char* _kRtSummaryTypeNames[] = {
  "MAX_VAL",
  "MIN_VAL",
  "AVG_VAL"
};
const std::map<int, const char*> _RtSummaryType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kRtSummaryTypeValues, _kRtSummaryTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RtSummaryType::type& val) {
  std::map<int, const char*>::const_iterator it = _RtSummaryType_VALUES_TO_NAMES.find(val);
  if (it != _RtSummaryType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kRtDataStateValues[] = {
  RtDataState::NOT_EXISTS,
  RtDataState::PROCESS_FAIL
};
const char* _kRtDataStateNames[] = {
  "NOT_EXISTS",
  "PROCESS_FAIL"
};
const std::map<int, const char*> _RtDataState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kRtDataStateValues, _kRtDataStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const RtDataState::type& val) {
  std::map<int, const char*>::const_iterator it = _RtDataState_VALUES_TO_NAMES.find(val);
  if (it != _RtDataState_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}

int _kErrorCodeValues[] = {
  ErrorCode::OTHER,
  ErrorCode::NOT_IMPLEMENT,
  ErrorCode::INVALID_PARAM,
  ErrorCode::CONNECT_FAILD
};
const char* _kErrorCodeNames[] = {
  "OTHER",
  "NOT_IMPLEMENT",
  "INVALID_PARAM",
  "CONNECT_FAILD"
};
const std::map<int, const char*> _ErrorCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kErrorCodeValues, _kErrorCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const ErrorCode::type& val) {
  std::map<int, const char*>::const_iterator it = _ErrorCode_VALUES_TO_NAMES.find(val);
  if (it != _ErrorCode_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


RequestException::~RequestException() throw() {
}


void RequestException::__set_code(const ErrorCode::type val) {
  this->code = val;
}

void RequestException::__set_message(const std::string& val) {
  this->message = val;
__isset.message = true;
}
std::ostream& operator<<(std::ostream& out, const RequestException& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RequestException::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_code = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast0;
          xfer += iprot->readI32(ecast0);
          this->code = (ErrorCode::type)ecast0;
          isset_code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_code)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RequestException::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestException");

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.message) {
    xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->message);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestException &a, RequestException &b) {
  using ::std::swap;
  swap(a.code, b.code);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

RequestException::RequestException(const RequestException& other1) : TException() {
  code = other1.code;
  message = other1.message;
  __isset = other1.__isset;
}
RequestException& RequestException::operator=(const RequestException& other2) {
  code = other2.code;
  message = other2.message;
  __isset = other2.__isset;
  return *this;
}
void RequestException::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestException(";
  out << "code=" << to_string(code);
  out << ", " << "message="; (__isset.message ? (out << to_string(message)) : (out << "<null>"));
  out << ")";
}

const char* RequestException::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: RequestException";
  }
}


RtValue::~RtValue() throw() {
}


void RtValue::__set_time(const int64_t val) {
  this->time = val;
}

void RtValue::__set_value(const double val) {
  this->value = val;
}
std::ostream& operator<<(std::ostream& out, const RtValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RtValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_time = false;
  bool isset_value = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->time);
          isset_time = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->value);
          isset_value = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_time)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_value)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t RtValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RtValue");

  xfer += oprot->writeFieldBegin("time", ::apache::thrift::protocol::T_I64, 1);
  xfer += oprot->writeI64(this->time);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("value", ::apache::thrift::protocol::T_DOUBLE, 2);
  xfer += oprot->writeDouble(this->value);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RtValue &a, RtValue &b) {
  using ::std::swap;
  swap(a.time, b.time);
  swap(a.value, b.value);
}

RtValue::RtValue(const RtValue& other3) {
  time = other3.time;
  value = other3.value;
}
RtValue& RtValue::operator=(const RtValue& other4) {
  time = other4.time;
  value = other4.value;
  return *this;
}
void RtValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RtValue(";
  out << "time=" << to_string(time);
  out << ", " << "value=" << to_string(value);
  out << ")";
}


RtSnapshotData::~RtSnapshotData() throw() {
}


void RtSnapshotData::__set_state(const RtDataState::type val) {
  this->state = val;
__isset.state = true;
}

void RtSnapshotData::__set_data(const RtValue& val) {
  this->data = val;
__isset.data = true;
}
std::ostream& operator<<(std::ostream& out, const RtSnapshotData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RtSnapshotData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast5;
          xfer += iprot->readI32(ecast5);
          this->state = (RtDataState::type)ecast5;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RtSnapshotData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RtSnapshotData");

  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->data.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RtSnapshotData &a, RtSnapshotData &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

RtSnapshotData::RtSnapshotData(const RtSnapshotData& other6) {
  state = other6.state;
  data = other6.data;
  __isset = other6.__isset;
}
RtSnapshotData& RtSnapshotData::operator=(const RtSnapshotData& other7) {
  state = other7.state;
  data = other7.data;
  __isset = other7.__isset;
  return *this;
}
void RtSnapshotData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RtSnapshotData(";
  out << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ")";
}


RtHistoryData::~RtHistoryData() throw() {
}


void RtHistoryData::__set_state(const RtDataState::type val) {
  this->state = val;
__isset.state = true;
}

void RtHistoryData::__set_data(const std::vector<RtValue> & val) {
  this->data = val;
__isset.data = true;
}
std::ostream& operator<<(std::ostream& out, const RtHistoryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RtHistoryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->state = (RtDataState::type)ecast8;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size9;
            ::apache::thrift::protocol::TType _etype12;
            xfer += iprot->readListBegin(_etype12, _size9);
            this->data.resize(_size9);
            uint32_t _i13;
            for (_i13 = 0; _i13 < _size9; ++_i13)
            {
              xfer += this->data[_i13].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RtHistoryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RtHistoryData");

  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
      std::vector<RtValue> ::const_iterator _iter14;
      for (_iter14 = this->data.begin(); _iter14 != this->data.end(); ++_iter14)
      {
        xfer += (*_iter14).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RtHistoryData &a, RtHistoryData &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

RtHistoryData::RtHistoryData(const RtHistoryData& other15) {
  state = other15.state;
  data = other15.data;
  __isset = other15.__isset;
}
RtHistoryData& RtHistoryData::operator=(const RtHistoryData& other16) {
  state = other16.state;
  data = other16.data;
  __isset = other16.__isset;
  return *this;
}
void RtHistoryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RtHistoryData(";
  out << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ")";
}


RtSummaryValue::~RtSummaryValue() throw() {
}


void RtSummaryValue::__set_maxVal(const RtValue& val) {
  this->maxVal = val;
__isset.maxVal = true;
}

void RtSummaryValue::__set_minVal(const RtValue& val) {
  this->minVal = val;
__isset.minVal = true;
}

void RtSummaryValue::__set_avgVal(const double val) {
  this->avgVal = val;
__isset.avgVal = true;
}
std::ostream& operator<<(std::ostream& out, const RtSummaryValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RtSummaryValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->maxVal.read(iprot);
          this->__isset.maxVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->minVal.read(iprot);
          this->__isset.minVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_DOUBLE) {
          xfer += iprot->readDouble(this->avgVal);
          this->__isset.avgVal = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RtSummaryValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RtSummaryValue");

  if (this->__isset.maxVal) {
    xfer += oprot->writeFieldBegin("maxVal", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->maxVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minVal) {
    xfer += oprot->writeFieldBegin("minVal", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->minVal.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.avgVal) {
    xfer += oprot->writeFieldBegin("avgVal", ::apache::thrift::protocol::T_DOUBLE, 3);
    xfer += oprot->writeDouble(this->avgVal);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RtSummaryValue &a, RtSummaryValue &b) {
  using ::std::swap;
  swap(a.maxVal, b.maxVal);
  swap(a.minVal, b.minVal);
  swap(a.avgVal, b.avgVal);
  swap(a.__isset, b.__isset);
}

RtSummaryValue::RtSummaryValue(const RtSummaryValue& other17) {
  maxVal = other17.maxVal;
  minVal = other17.minVal;
  avgVal = other17.avgVal;
  __isset = other17.__isset;
}
RtSummaryValue& RtSummaryValue::operator=(const RtSummaryValue& other18) {
  maxVal = other18.maxVal;
  minVal = other18.minVal;
  avgVal = other18.avgVal;
  __isset = other18.__isset;
  return *this;
}
void RtSummaryValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RtSummaryValue(";
  out << "maxVal="; (__isset.maxVal ? (out << to_string(maxVal)) : (out << "<null>"));
  out << ", " << "minVal="; (__isset.minVal ? (out << to_string(minVal)) : (out << "<null>"));
  out << ", " << "avgVal="; (__isset.avgVal ? (out << to_string(avgVal)) : (out << "<null>"));
  out << ")";
}


RtSummaryData::~RtSummaryData() throw() {
}


void RtSummaryData::__set_state(const RtDataState::type val) {
  this->state = val;
__isset.state = true;
}

void RtSummaryData::__set_data(const std::vector<RtSummaryValue> & val) {
  this->data = val;
__isset.data = true;
}
std::ostream& operator<<(std::ostream& out, const RtSummaryData& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t RtSummaryData::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast19;
          xfer += iprot->readI32(ecast19);
          this->state = (RtDataState::type)ecast19;
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->data.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->data.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += this->data[_i24].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RtSummaryData::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RtSummaryData");

  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32((int32_t)this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.data) {
    xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->data.size()));
      std::vector<RtSummaryValue> ::const_iterator _iter25;
      for (_iter25 = this->data.begin(); _iter25 != this->data.end(); ++_iter25)
      {
        xfer += (*_iter25).write(oprot);
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RtSummaryData &a, RtSummaryData &b) {
  using ::std::swap;
  swap(a.state, b.state);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

RtSummaryData::RtSummaryData(const RtSummaryData& other26) {
  state = other26.state;
  data = other26.data;
  __isset = other26.__isset;
}
RtSummaryData& RtSummaryData::operator=(const RtSummaryData& other27) {
  state = other27.state;
  data = other27.data;
  __isset = other27.__isset;
  return *this;
}
void RtSummaryData::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RtSummaryData(";
  out << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "data="; (__isset.data ? (out << to_string(data)) : (out << "<null>"));
  out << ")";
}

}}}}}} // namespace
